#!/usr/bin/env bash
#
# ansrole
#   executes a role against hosts or inventory groups, passing varval args
#
# usage:
#   ansrole [-n | --nofacts] [--syntax] [--step] \
#           [-U | --unbecome] [[-B | --buser][=]<become-user>]
#           [-C | --check] [-D | --diff] [-p | --prefix] \
#           [-v | --verbose] ... \
#           [[-k | --key][=]<ssh_keyfile>] \
#           [[-u | --user][=]<remote_user>] \
#           [[-f | --forks][=]<fork_limit>] \
#           [[-s | --start][=]<start_at_task>] \
#           [[-c | --connection][=]<connection_plugin>] \
#           [[-i | --inventory][=]<inventory_override>] [...] \
#           <apply-onto-pattern | multi:pattern>:[:*]<role-to-apply> \
#           [<extra-var-name=value> | <json-var>] [...]
# desc:
#   - executes role in "./roles/<role-to-apply>/" onto <apply-onto-pattern>
#   - passes trailing var=val params as '-e' args to ansible-playbook
#   - uses rc-configured inventory; pass '--inventory=' to override
#   - creates symlinks to play/role dirs in a `mktemp -d` directory
#   - runs in the tmpdir after creating temporary playbook with static role
#   - (ansible can only do playbook-relative, not cwd-relative paths)
#
# todo:
#   - once 22983 is implemented, tmpdir won't be needed anymore
#   - also see 21890 because include_role won't expose vars until then
#   - and 19305 will allow roles to be incl dynamically with include_role:
#   - and 22985 with roles: itself instead of needing a task
#   - use our own option for the host_list case that won't need 'all'
#
# scott@smemsh.net
# https://github.com/smemsh/setup/
# https://spdx.org/licenses/GPL-2.0
#
##############################################################################

anscfg=.ansible.cfg

# pattern actually used when 'all' requested and default inventory in use
allnodes="all:!pdsh_all_skip"

tmpdir=`mktemp -d /tmp/ansrole-XXXXXXXX` || exit 121
#trap "rm -rf ${tmpdir:?}" EXIT

bomb () { echo "${FUNCNAME[1]}: ${*}, aborting" >&2; false; exit; }
err  () { echo "${FUNCNAME[1]}: ${*}" >&2; }

usage_until=todo:
usagex () { usage; false; exit; }
usage ()
{
	grep -B 999 -m 1 '^$' "$BASH_SOURCE"  | # until first blank
	grep -B 999 -m 1 "^..${usage_until}$" | # until stop record
	head -n -2 |	# but not the match
	tail -n +3 |	# or interpreter line
	cut -b 3-	# strip comment prefix
}

###

check_sanity ()
{
	if ! test -f $anscfg
	then err "cwd must be a playbase"; false; fi
}

# - ansrole [options] <applyspec> [var=val | json] [...]
# - applyspec: either <pattern>::*<role> or <multi>:<pattern>:*<role>
# - used as a "--limit=<onto>" with playbook target always 'all'
# - special case: 'all' with default inventory gets --limit="$allnodes"
# - to use a host_list instead, use '--inventory=host1,host2,'
#
process_args ()
{
	local onto role arg
	local ours mods flags opts invs exts helps
	local chars longs
	local -a pats=(); local i

	# 1/3 header

	# 2/3
	ours=pnU mods=k:B:s: flags=DCv opts=u:f:c: invs=i: exts=e: helps=h
	chars=${ours}${mods}${flags}${opts}${invs}${exts}${helps}
	longs=(
	-l prefix,nofacts                           # ours
	-l syntax,key:,buser:,start:                # mods
	-l step,diff,check,verbose                  # flags
	-l user:,forks:,connection:                 # opts
	-l inventory:                               # invs
	-l extra:,extra-vars:                       # exts
	-l help                                     # helps
	); eval set -- $(getopt -n $invname -o $chars "${longs[@]}" -- "$@")

	# 3/3
	while true; do case $1 in

	# ours
	(-p|--prefix) let prefix++; shift;;
	(-n|--nofacts) dofacts=false; shift;;
	(-U|--unbecome) become=false; shift;;

	# mods
	(--syntax) playopts+=(--syntax-check); shift;;
	(-k|--key) playopts+=(--private-key $2); shift 2;;
	(-B|--buser) playopts+=(--become-user $2); shift 2;;
	(-s|--start) playopts+=(--start-at-task $2); shift 2;;

	# flags
	(--step) ;&
	(-D|--diff) ;&
	(-C|--check) ;&
	(-v|--verbose) playopts+=($1); shift;;

	# opts
	(-u|--user) ;&
	(-f|--forks) ;&
	(-c|--connection) playopts+=($1 $2); shift 2;;

	# invs: if user supplies the inventory, don't unselect pdsh_all_skip
	(-i|--inventory) allnodes=all; playopts+=($1 $2); shift 2;;

	# exts: reject extra vars from options, allow only in trailing args
	(-e|--extra|--extra-vars)
	bomb "give all extras at end using var=val or json";;

	(-h|--help) usage; true; exit;;
	(--) shift; break;;
	(*) err "unrecognized option '$1'"; usagex;;

	esac; done

	# first non-option arg is a ':'-delimited list of patterns,
	# followed by any number of contiguous ':', followed by rolename
	#
	if ! [[ $1 =~ ^(([^:]+:?)+):+([^:]+)$ ]]
	then bomb "invalid pattern:role spec"; fi
	onto="${BASH_REMATCH[1]%:}"
	role=${BASH_REMATCH[3]}
	shift

	# if any of the patterns are 'all', add the skip group,
	# these are typically machines which don't exist or are down
	#
	pats=($(IFS=: compgen -W "$onto"))
	for ((i = 0; i < ${#pats[@]}; i++))
	do [[ "${pats[i]}" == 'all' ]] && pats[$i]="$allnodes"; done
	IFS=:; onto="${pats[*]}"; unset IFS

	# we use the pattern as a limit, and always target the 'all'
	# group in the constructed playbook itself
	#
	[[ $onto && $role ]] && rolename=$role || usagex
	limits=(--limit="$onto")

	# rest are var=val or json strings for ansible-playbook -e
	for arg
	do
		local name val
		if ((prefix)) && [[ $arg =~ ^([[:alnum:]_]+)=(.*)$ ]]
		then
			# if requested, prefix vars with role name to save
			# typing.  not all roles have all variables prefixed
			# so we don't make this the default but it's handy
			# for some roles.  does not handle json vars however
			#
			name=${BASH_REMATCH[1]}
			val="${BASH_REMATCH[2]}"
			arg=${rolename}_$name="$val"
		fi
		extras+=(-e "$arg")
	done
}

generate_tmp_playbook ()
{
	# - linear: some roles require lockstep tasks or disaster will
	#   ensue, like mysql master update phase.  change it only very
	#   carefully.  TODO: add script args to control strategy/params
	#
	# - vars_files: see ansible issue 85051, eventually vars_files
	#   can take a templated list and then we can generate it with a
	#   fileglob lookup
	#
	cat <<- % >$tmpplay
	- hosts: all
	  strategy: linear
	  serial: 100%
	  become: ${become:-'true'}
	  gather_facts: ${dofacts:-'true'}
	  vars_files: [$(printf %s, vars/*.yml)]
	  roles: ['$rolename']
	%
}

# work around ansible requiring everything to be relative to the
# playbook, by making a temporary root dir of our own, populated by
# symlinks to the real playbook_dir.  mainly this is to avoid writes in
# what is a git checkout, and so we can leave temporary files for debug
#
init_tmp_playbase ()
{
	local dir
	for dir in */
	do dir=${dir%/}; ln -s $(readlink -f $dir) $tmpdir/; done
	tmpplay=$tmpdir/ansrole-${rolename:?}.yml
}

ansrole ()
{
	init_tmp_playbase &&
	generate_tmp_playbook &&
	set -x &&
	ansible-playbook \
		"${playopts[@]}" \
		"${limits[@]}" \
		"${extras[@]}" \
		$tmpplay \
	;
}

main ()
{
	process_args "$@" \
	&& check_sanity \
	|| bomb "initialization failed"

	if [[ $(declare -F $invname) ]]
	then $invname "${args[@]}"
	else bomb "unimplemented command '$invname'"; fi
}

invname=${0##*/} # 0.8.0
invdir=${0%/*}

main "$@"
